fmt := import("fmt")
rand := import("rand")

// Lifecycle-scripted AI example.
// Contract:
// - define `initial_state`
// - define `onEnter(engine, state, current_state)`
// - define `update(engine, state, current_state)`
// - define `onExit(engine, state, current_state)`

attackCDTimer := 100
// TODO - change to 180
introTimer := 1
cameraShakeIntensity := 6.0

initial_state := "idle"

ensure := func(state) {
    if state["attack_cd"] == undefined {
        state["attack_cd"] = 0
    }
    if state["intro_timer"] == undefined {
        state["intro_timer"] = 0
    }
    if state["hit_timer"] == undefined {
        state["hit_timer"] = 0
    }
    if state["phase"] == undefined {
        state["phase"] = 0
    }
}

onEnter := func(engine, state, current_state) {
    ensure(state)

    if current_state == "idle" {
        engine.set_animation("idle")
        engine.stop_x()
    } else if current_state == "phase_1_intro" {
        engine.set_animation("idle")
        engine.play_audio("roar")
        engine.stop_player_input()
        engine.camera_shake({"frames": introTimer, "intensity": cameraShakeIntensity})
        state["phase"] = 1
        state["intro_timer"] = introTimer
    } else if current_state == "phase_2" {
        engine.play_audio("roar")
        state["phase"] = 2
        state["intro_timer"] = introTimer
        engine.camera_shake({"frames": introTimer, "intensity": cameraShakeIntensity})
    } else if current_state == "follow" {
        engine.set_animation("run")
    } else if current_state == "attack_regular" {
        engine.set_animation("attack_regular")
        engine.play_audio("attack")
    } else if current_state == "attack_overhead" {
        engine.jump(10)
        engine.set_animation("attack_overhead")
        engine.play_audio("attack")
    } else if current_state == "death" {
        engine.set_animation("death")
        engine.disable_hazard()
        engine.play_audio("death")
    }
}

update := func(engine, state, current_state) {
    ensure(state)

    if state["attack_cd"] > 0 {
        state["attack_cd"] = state["attack_cd"] - 1
    }

    if state["intro_timer"] > 0 {
        state["intro_timer"] = state["intro_timer"] - 1
    }

    if engine.consume_event("phase_intro") {
        engine.transition("phase_1_intro")
        return
    }

    if engine.consume_event("phase_2") {
        engine.transition("phase_2")
        return
    }

    if engine.event("out_of_health") {
        engine.transition("death")
        return
    }

    if engine.consume_event("hit") {
        engine.add_white_flash(20)
        return
    }

    if current_state == "phase_1_intro" {
        engine.stop_x()
        
        if state["intro_timer"] <= 0 {
            engine.transition("idle")
        }
        return
    }

    if current_state == "idle" {
        engine.stop_x()

        if engine.event("sees_player") {
            if engine.event("in_attack_range") && state["attack_cd"] <= 0 {
                if state["phase"] == 1 {
                    engine.transition("attack_regular")
                    return
                } else {
                    i := rand.intn(2)
                    if i == 0 {
                        engine.transition("attack_regular")
                    } else {
                        engine.transition("attack_overhead")
                    }
                    return 
                }
            }

            engine.transition("follow")
            return
        }
        return
    }

    if current_state == "follow" {
        engine.move_towards_player()
        engine.face_player()

        if engine.event("loses_player") {
            engine.transition("idle")
            return
        }
        
        if engine.event("in_attack_range") && state["attack_cd"] <= 0 {
            if state["phase"] == 1 {
                engine.transition("attack_regular")
                return
            } else {
                i := rand.intn(2)
                if i == 0 {
                    engine.transition("attack_regular")
                } else {
                    engine.transition("attack_overhead")
                }
                return 
            }
        }
        return
    }

    if current_state == "attack_regular" {
        engine.stop_x()
        engine.face_player()
        if engine.event("out_attack_range") && engine.animation_finished() {
            engine.transition("follow")
            return
        }

        if engine.event("in_attack_range") && engine.animation_finished() {
            engine.transition("idle")
        }
        return
    }

    if current_state == "attack_overhead" {
        isGrounded := engine.is_grounded()
        if state["prev_is_grounded"] != isGrounded {
            pos := engine.get_position()
            playerPos := engine.get_player_position()
  
            engine.instantiate_shockwave({"x": pos[0]+12, "y": pos[1], "facing_left": playerPos[0] < pos[0]})
        }

        state["prev_is_grounded"] = isGrounded
        engine.face_player()
        if engine.event("out_attack_range") && engine.animation_finished() {
            engine.transition("follow")
            return
        }

        if engine.event("in_attack_range") && engine.animation_finished() {
            engine.transition("idle")
        }
        return
    }
}

onExit := func(engine, state, current_state) {
    if current_state == "phase_1_intro" {
        engine.restore_player_input()
    }

    if current_state == "attack_regular" || current_state == "attack_overhead" {
        if state["attack_cd"] < attackCDTimer {
            state["attack_cd"] = attackCDTimer + rand.intn(30)
        }
    }
}
